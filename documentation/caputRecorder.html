<HTML> <HEAD>
<TITLE>caputRecorder</TITLE>
</HEAD>
<BODY>

<H1><center>caputRecorder 1.4</center></h1>

<P><center><IMG SRC="caputRecorder_small.adl.jpg"><br>caputRecorder_small.adl</IMG></center>

<P>caputRecorder supports the recording and playback of a series of caputs.  It records each caput as a python
command, and a series of caputs as a python function - also called here a
<b><i>macro</i></b>.  caputRecorder can also serve as a simple user interface
for delivering canned python functions to end users.

<blockquote>

<i>caput</i> is short for "Channel Access put".  When you press a button, or
make a menu selection, in an MEDM (or EDM, caQtDM, CSS-BOY, etc.) display, you
are doing a caput.  Any program that writes to EPICS PVs does so by doing
caputs.

</blockquote>

<P>One use for caputRecorder is to orchestrate measurements involving several
series of steps that users know how to do manually, but for which no software
has been written.  If users can do a measurement step manually while the
recorder is on, they will in effect have written software to automate that
measurement step, and they can then combine several such steps as needed to
perform a particular instance of the measurement type.

<P>Another use is to improve communication between users and software
developers who support them.  Rather than describing needed software in general
terms, or laboriously listing required steps, a user can simply record them, and
hand the developer the equivalent python code.

<P>Another use is to assist in troubleshooting, by recording the exact sequence
of caputs that produced a problem.

<H2> How does this work? </h2>

EPICS access security has the ability to call a user function whenever a caput
that meets certain criteria is received by an IOC.  The function is called an
<i>access-security trap listener</i>, and caputRecorder provides one which
writes a <i>caput-notification</i> string of the form "pvname,value,user@host"
to an EPICS PV whenever an eligible caput is received by the IOC.

<p>caputRecorder provides an EPICS database that contains the EPICS PV mentioned
above, and other PVs that function as caputRecorder's user interface.  The
user-interface PVs are monitored by the python program caputRecorder.py, and
direct its operation.  When caputRecorder.py is given a macro name and told
to record, it begins monitoring the caput-notification PVs of specified IOCs,
and writes python commands corresponding to each notification into the python
program file macros.py.

<P>caputRecorder.py also inspects the file macros.py and writes the names of
macros in the file to a set of EPICS menus (that is, to mbbo records).  A user
can select a macro name from those menus, and tell caputRecorder to execute that
macro.

<P>Thus, each IOC is responsible for telling caputRecorder that it received a
caput, and one IOC also hosts the database that tells caPutRecorder what to do.

<H2> Requirements, configuration </h2>

The caputRecorder database uses record types from the synApps
<a href="http://www.aps.anl.gov/bcda/synApps/busy/busy.html">busy</a>
and
<a href="http://www.aps.anl.gov/bcda/synApps/calc/calc.html">calc</a>
modules.

The workstation on which caputRecorder.py runs must have python with
the <a href="http://cars.uchicago.edu/software/python/pyepics3">PyEpics</a>
module installed.

<P>EPICS IOCs that participate in caputRecorder, either by posting the caputs
they receive, or by hosting caputRecorder's user interface, must be prepared as
follows.  (These are excerpts from the synApps xxx module, release R5-8, which
is already configured to use caputRecorder.)

<ol>
<li><P>Add <code>CAPUTRECORDER</code> to the IOC's RELEASE file

<li><P>Include <code>caputRecorder.dbd</code> in the IOC's .dbd file.

<li><P>Link the IOC's code against the <code>caputRecorder</code> library.

<li><P>Load the database <code>caputRecorder.db</code>, for example with this
excerpt from st.cmd:

<blockquote>
<pre>
dbLoadRecords("$(CAPUTRECORDER)/caputRecorderApp/Db/caputRecorder.db","P=xxx:,N=300")
</pre>
</blockquote>

<blockquote>
where <code>N</code> is the length of the longest caput-notification string
("pvname,value,user@host") that will be sent to the recorder.
</blockquote>

<li><P>If you're using autosave, you'll probably also want to include
<code>caputRecorder_settings.req</code> in the IOC's
<code>auto_settings.req</code> file:

<pre>
file caputRecorder_settings.req P=xxx:,N=300
</pre>

If you do this, you must also add the following line to save_restore.cmd:

<pre>
set_requestfile_path("$(CAPUTRECORDER)", "caputRecorderApp/Db")
</pre>


<li>Register caputRecorder's access-security trap listener, for example with the
following excerpt from st.cmd.  (Note that this command must be executed
<i>after</i> iocInit.)

<blockquote>
<pre>
registerCaputRecorderTrapListener('xxx:caputRecorderCommand')
</pre>
</blockquote>

<blockquote>

where <code>xxx:caputRecorderCommand</code> is the name of the PV to which
caput-notification strings will be written.

</blockquote>

<li>Run EPICS access security with an access-security file that specifies
<code>TRAPWRITE</code> for the desired users and hosts.  Here is a sample
excerpt from st.cmd:

<blockquote>
<pre>
iocsh
asSetFilename("$(TOP)/iocBoot/accessSecurity.acf")
exit
</pre>
</blockquote>

where the file <code>accessSecurity.acf</code> might have the following content:

<blockquote>
<pre>
HAG(workstation) {mooneylinux.aps.anl.gov}
UAG(user) {mooney}
ASG(DEFAULT) {
	RULE(1,READ)
	RULE(1,WRITE,TRAPWRITE) {
		HAG(workstation)
		UAG(user)
	}
	RULE(1,WRITE)
}
</pre>

<P>This file grants write permission to anybody on any host, and specifies that
TRAPWRITE is in effect only for user <i>mooney</i> on workstation
<i>mooneylinux</i>.  You probably don't want TRAPWRITE in effect for caputs from
an IOC, but do want it for caputs from channel-access clients, such as MEDM, that
aren't in an IOC.

<P>Note that the order in which rules occur in the file matters for TRAPWRITE. 
If <code>RULE(1,WRITE)</code> were encountered before
<code>RULE(1,WRITE,TRAPWRITE)</code>, TRAPWRITE would not be in effect for
anybody, because everybody is covered by <code>RULE(1,WRITE)</code>.

<P>If you can't or don't want to select users and hosts using access-security
rules, you can specify TRAPWRITE for all, and select users and hosts with
caputRecorder's user interface.  The simplest possible access-security file that
will work for caputRecorder is the following:

<pre>
ASG(DEFAULT) {
	RULE(1,WRITE,TRAPWRITE)
}
</pre>
</blockquote>


<li>One IOC from which caputs are to be recorded will have its
<code>caputRecorder.db</code> database displayed to the user via MEDM (or
caQtDM, or CSS-BOY).  The Python program caputRecorder.py will also
monitor and write to this database.

<P><li>The following environment variables must be set before running MEDM
(caQtDM, etc.):
<dl> 

<P><dt>START_PUTRECORDER<dd>The path to a script that starts caputRecorder.py. 
This will be used by the "!(re)start recorder" button described below.  There is
a sample copy of a script that does this for Linux here:

<pre>caputRecorder/example_start_putrecorder</pre>

It is important that only one copy of caputRecorder.py (for a given
user-interface database) is running at a time. caputRecorder detects the launch
of a new copy of itself that uses the same control PVs, and exits.


<P><dt>MACROS_PY<dd>The path to the file macros.py, in which caputs will be
recorded.  There is an example copy of macros.py here:
<pre>caputRecorder/caputRecorderApp/op/python/example_macros.py</pre>

<P><dt>EDITOR<dd>The command that invokes your preferred editor, which will be used
by the "!edit macros.py" button described below.

</dl>

</ol>

<h2>How to use</h2>

<P><center><IMG SRC="caputRecorder.adl.jpg"><br>caputRecorder.adl</IMG></center>

<P>Referring to the caputRecorder.adl display above, from top to bottom:

<ul>

<li><P>The button labelled "!(re)start recorder" starts or restarts the python
program caputRecorder.py.

<li><P>The heart symbol to the right of the "!(re)start recorder" button blinks
while caputRecorder.py is running and responsive to its control PVs.  After the
control IOC reboots, caputRecorder remains unresponsive for 10 seconds, to avoid
misconstruing initial monitors from control PVs as commands to execute.

<li><P><b>Inputs</b>

<ul>


<li><P>The text-monitor field labelled "caput:" displays the PV name and value
most recently written to the IOC.  This field is written to by the
access-security trap listener, and is updated whether or not a python
macro is being recorded.

<li><P>The text-entry field labelled "comment:" allows you to add comments to
the macro being recorded.  This field is monitored only while a macro is being
recorded.

<li><P>The text-entry field labelled "delay" specifies the time delay in seconds
of the delay command that will be added to the macro being recorded when you
press the "Add" button.  The actual python code for this command will be
something like <code>time.sleep(1.200)</code>.  After caputRecorder.py has
written the delay command, it will press the "Done" button.

<li><P>The text-entry field labelled "time to wait for completion:" specifies
the time in seconds that python will wait for completion of a macro command 
that does a caput to an EPICS PV, before going on to the next command. 
"Completion" means completion of any EPICS processing that results from the
execution of that caput.  It's ok to change this time while a macro is being
recorded.

</ul>

<li><P><b>Record Macro</b> <ul> <li><P>The text-entry field labelled "macro
name" should contain the name of the macro (python function) you want to
record.  Note that you aren't permitted to use a macro name that already exists
in macros.py. Also note that the macro name must start with a letter, and must
consist of letters digits, and underscores.  caputRecorder will enforce this by
prepending "a" or replacing offending characters with underscores.  The maximum
length of a macro name is 25 characters; this is enforced by the length of an
mbboRecord string field.

<li><P>The choice button labelled "record puts" is used to start and stop
recording.  While recording, you can write to EPICS PVs via any EPICS client,
and you can also execute any macro that has already been recorded.

<li><P>If you execute macro <b>A</b> while recording macro <b>B</b>, and then
stop recording while macro <b>A</b> is still executing, you must wait for
macro <b>A</b> to finish before starting a new recording of another macro.

<li><P>When you execute macro <b>A</b> while recording macro <b>B</b>,
caputRecorder will suppress recording of the caputs from macro <b>A</b>, and
will simply record a function call to macro <b>A</b> in macro <b>B</b>.

</ul>

<li><P><b>Select Macro</b>

<ul>

<li><P>The button labelled "!edit macros.py" invokes the command named by
the environment variable EDITOR on the file macros.py.

<li><P>The gray boxes are menus, which will contain the names of recorded
macros, and they are the means by which a macro can be selected manually for
playback.  Currently caputRecorder supports six menus, each of which can hold 16
macro names.

<li><P>The text-monitor and text entry fields under the "arguments for selected
macro" label are the names and default values of the arguments, if any, of
the selected macro.  As recorded, macros have no arguments, but you can
edit the python code.  If you do, you must use the "name=value" syntax for
defining macro arguments.  For example, here is a macro definition with one
string argument, and three numeric arguments:

<pre>
def motorscan(motor="m1", start=0, end=1, npts=11):
</pre>


<li><P>Normally, you should not have to press the "Reload Macros" button,
because caputRecorder reloads automatically after a new macro has been recorded.
However, if you edit macros.py manually, you must press "Reload Macros"
to tell caputRecorder to reread the file. (If you deleted a function definition
from macros.py, reloading isn't sufficient; you must restart
caputRecorder, using the "!(re)start recorder" button.)

<li><P>The "Refresh Menus" button is needed whenever macros.py has
changed, whether by recording a macro, or by manually editing the file.

</ul>

<li><P><b>Playback Macro</b>

<ul>

<li><P>The text-monitor field contains the name of the selected macro.  To play
it back (to cause python to execute it) press the "Do" button.  When the
macro has finished, the "Do" button will return to the "Done" state.  If you
want to execute the macro repeatedly, enter the number of times in the field
labelled "times."

<li><P>The "Abort" button is intended to stop an executing macro, and also to do
any other abort-related work specified in the function named "_abort" in
macros.py.  The supplied <i>example_macros.py</i> defines an abort
function that aborts scans, halts motors, and stop the scaler named "scaler1".

<li><P>An EPICS client or record can trigger macro execution by writing a macro
name to "$(P)caputRecorderMacro", and then writing "Do" (or the number 1) to 
"$(P)caputRecorderExecuteMacro".  The client should wait for completion after
both writes, to ensure that any default argument values are in place before
executing, and to wait for macro execution to finish.

</ul>

</ul>

<H2> Selecting what gets recorded </h2>

You probably don't want to record all caputs that happen among your IOCs and
clients, but only those done by users.  One way of filtering was shown above, in
"Requirements, configuration". User-specified filtering is easier, and can be
done at run time with caputRecorder's user interface. <ol>

<li>You can choose which users' caputs will be recorded by specifying usernames
to <code>caputRecorderUsers</code>.  (See "Record caputs from whom?" in
the figure below.)  To disable recording from a specific user, put a minus sign
in front of the username.

<P><li>You can choose which hosts' caputs will be recorded by specifying
hostnames to <code>caputRecorderHosts</code>.  (See "Record caputs from whom?"
in the figure below.)  Only the first element of a host name need be specified.  (For
example, "mooneylinux.aps.anl.gov" is used as "mooneylinux".)

<P><li>You can choose which IOCs caputRecorder monitors, by specifying prefixes
to <code>caputRecorderPrefixes</code>.  (See "Record caputs received by which IOCs?" in
the figure below.)  Unlike user and host choices, this choice does not take
effect while a macro is being recorded.  Also unlike user and host choices, this
choice is not about the sender of a caput, but about the recipient.

<P>On startup, caputRecorder monitors the iocs whose prefixes are specified on the
command line.  If <code>caputRecorderPrefixes</code> is not empty, it will
override the initial list of iocs.

<P><li>Caputs within an IOC will never be recorded, because they don't go
through access security.

<P><center><IMG SRC="caputRecorderConfigure.adl.jpg"><br>caputRecorderConfigure.adl</IMG></center>

<H2> Discussion </h2>

<ul>

<li><P>

<P>caputRecorder "reads" the macros.py file by importing it:

<pre>
import macros.py
</pre>

After macros.py has been changed, caputRecorder "rereads" it by
reloading :

<pre>
reload(macros)
</pre>

Reload will overwrite objects in the live macros module with values from
macros.py, but it will not delete any objects.  If you delete a function
definition or a global variable from macros.py, reloading won't remove it from
the live copy of the macros module; you have to restart python, which you can do
by pressing the "(re)start recorder" button.

<li><P>
caputRecorder records a caput with the following python code:

<pre>
epics.caput("xxx:scan1.P1PV","xxx:m2.VAL", wait=True, timeout=300.0)
</pre>

This code will request a completion callback from EPICS, and will wait as long
as 300 seconds for the callback to arrive.  This is probably much longer than
most operations will take to complete, but five minutes is not long enough for
many scans.  If you use caputRecorder to execute scans, you'll probably want to
increase the "time to wait for completion" described in the "How to
use"/"Inputs" section.

<P>Currently, it is not an error for a macro to timeout while waiting for a
callback.  Python will simply move on to the next command and execute it.
Currently, caputRecorder does not take advantage of PyEpics' ability to execute
several commands and then wait for all to complete (that is, the "use_complete"
option of the PV class's put() method).

<li><P><a href="http://www-csr.bessy.de/control/SoftDist/caPutLog">caPutLog</a>
can also trap caputs and write them to a PV.  A proof-of-principle
implementation of caputRecorder used caPutLog 3.4 to do this, but it didn't
handle long strings.

<li><P>In EPICS 3.14.12.4 and earlier, and in versions of 3.15 earlier than
3.15.2, access security did not provide the data from a caput to the
asTrapListener, so caputRecorder used dbGetField() to get the data after it had
been written. This was ok for most PVs, but some PVs (for example, the tweak
fields of a motor record) have their values changed immediately after being
written, and caputRecorder was getting the final value, rather than the value
the user actually wrote.  Andrew Johnson fixed this by providing data to the
asTrapListener, and caputRecorder R1-4 and later will use this capability if it
is present.

<li><P>caputRecorder R1-4 monitors the connection status of one of its PVs, and
exits of that PV remains disconnected for more than 10 seconds.

 </BODY>
