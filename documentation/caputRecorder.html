<HTML> <HEAD>
<TITLE>caputRecorder</TITLE>
</HEAD>
<BODY>

<H1> caputRecorder </h1>

caputRecorder supports the recording and playback of a series of caputs (e.g.,
mouse clicks and typing into an MEDM window).  It records each caput as a python
command, and a series of caputs as a python function - also called here a
<b><i>macro</i></b>.  caputRecorder can also serve as a simple user interface
for delivering canned python functions to end users.

<H2> How does this work? </h2>

EPICS access security has the ability to call a user function whenever a caput
that meets certain requirements is received by an IOC.  The function is called
an <i>access-security trap listener</i>, and caputRecorder provides one which
writes a <i>caput-notification</i> string of the form "pvname,value,user@host"
to an EPICS PV whenever an eligible caput is received by the IOC.

<p>caputRecorder provides an EPICS database that contains the EPICS PV mentioned
above, and other PVs that function as caputRecorder's user interface.  The
user-interface PVs are monitored by the python program caputRecorder.py, and
direct its operation.  When caputRecorder.py is given a function name and told
to record, it begins monitoring the caput-notification PVs of specified IOCs,
and writes python commands corresponding to each notification into the python
program file macros.py.

<P>caputRecorder.py also inspects the file macros.py and writes the names of
functions in the file to a set of EPICS menus (that is, to mbbo records).  A
user can select a function name from those menus, and tell caputRecorder to
execute that function.

<P>Thus, each IOC is responsible for telling caputRecorder that it received a
caput, and one IOC also tells caPutRecorder what to do.

<H2> Requirements, configuration </h2>

The workstation on which <i>caputRecorder.py</i> runs must have python with
the <a href="http://cars.uchicago.edu/software/python/pyepics3">PyEpics</a>
module installed.

<P>EPICS IOCs that participate in caputRecorder, either by posting the caputs
they receive, or by hosting caputRecorder's user interface, must be prepared as
follows.  (These are excerpts from the synApps xxx module, release R5-8, which
is already configured to use caputRecorder.)

<ol>
<li><P>Add <code>CAPUTRECORDER</code> to the IOC's RELEASE file

<li><P>Include <code>caputRecorder.dbd</code> in the IOC's .dbd file.

<li><P>Link the IOC's code against the <code>caputRecorder</code> library.

<li><P>Load the database <code>caputRecorder.db</code>, for example with this
excerpt from st.cmd:

<blockquote>
<pre>
dbLoadRecords("$(CAPUTRECORDER)/caputRecorderApp/Db/caputRecorder.db","P=xxx:,N=300")
</pre>
</blockquote>

<blockquote>
where <code>N</code> is the length of the longest caput-notification string
("pvname,value,user@host") that will be sent to the recorder.
</blockquote>

<li><P>If you're using autosave, you'll probably also want to include
<code>caputRecorder_settings.req</code> in the IOC's
<code>auto_settings.req</code> file:

<pre>
file caputRecorder_settings.req P=xxx:,N=300
</pre>

If you do this, you must also add the following line to save_restore.cmd:

<pre>
set_requestfile_path("$(CAPUTRECORDER)", "caputRecorderApp/Db")
</pre>


<li>Register caputRecorder's access-security trap listener, for example with the
following excerpt from st.cmd.  (Note that this command must be executed
<i>after</i> iocInit.)

<blockquote>
<pre>
registerCaputRecorderTrapListener('xxx:caputRecorderCommand')
</pre>
</blockquote>

<blockquote>

where <code>xxx:caputRecorderCommand</code> is the name of the PV to which
caput-notification strings will be written.

</blockquote>

<li>Run EPICS access security with an access-security file that specifies
<code>TRAPWRITE</code> for the desired users and hosts.  Here is a sample
excerpt from st.cmd:

<blockquote>
<pre>
iocsh
asSetFilename("$(TOP)/iocBoot/accessSecurity.acf")
exit
</pre>
</blockquote>

where the file <code>accessSecurity.acf</code> might have the following content:

<blockquote>
<pre>
HAG(workstation) {mooneylinux.aps.anl.gov}
UAG(user) {mooney}
ASG(DEFAULT) {
	RULE(1,READ)
	RULE(1,WRITE,TRAPWRITE) {
		HAG(workstation)
		UAG(user)
	}
	RULE(1,WRITE)
}
</pre>

<P>This file grants write permission to anybody on any host, and specifies that
TRAPWRITE is in effect only for user <i>mooney</i> on workstation
<i>mooneylinux</i>.  You probably don't want TRAPWRITE in effect for caputs from
an IOC, but do want it for caputs from channel-access clients, such as MEDM, that
aren't in an IOC.

<P>Note that the order in which rules occur in the file matters for TRAPWRITE. 
If <code>RULE(1,WRITE)</code> were encountered before
<code>RULE(1,WRITE,TRAPWRITE)</code>, TRAPWRITE would not be in effect for
anybody, because everybody is covered by <code>RULE(1,WRITE)</code>.

<P>If you can't or don't want to select users and hosts using access-security
rules, you can specify TRAPWRITE for all, and select users and hosts with
caputRecorder's user interface.  The simplest possible access-security file that
will work for caputRecorder is the following:

<pre>
ASG(DEFAULT) {
	RULE(1,WRITE,TRAPWRITE)
}
</pre>
</blockquote>


<li>One IOC from which caputs are to be recorded will have its
<code>caputRecorder.db</code> database displayed to the user via MEDM (or
caQtDM, or CSS-BOY).  The Python program <i>caputRecorder.py</i> will also
monitor and write to this database.

<P><li>The following environment variables must be set before running MEDM
(caQtDM, etc.):
<dl> 

<dt>START_PUTRECORDER<dd>The path to a script that starts caputRecorder.py. 
This will be used by the "!(re)start recorder" button described below.  There is a sample copy
of a script that does this:
<code>caputRecorder/example_start_putrecorder</code>.

<dt>MACROS_PY<dd>The path to the file, macros.py, in which caputs will be
recorded.  There is an example copy of macros.py:
<code>caputRecorder/caputRecorderApp/op/python/example_macros.py</code>.

<dt>EDITOR<dd>The command that invokes your preferred editor, which will be used
by the "!edit macros.py" button described below.

</dl>

</ol>

<h2>How to use</h2>

<P><center><IMG SRC="caputRecorder.adl.jpg"><br>caputRecorder.adl</IMG></center>

Referring to the caputRecorder.adl display above, from top to bottom:

<ul>

<li><P>The button labelled "(re)start recorder" starts or restarts the python
program <i>caputRecorder.py</i>

<blockquote>
As implemented, the MEDM display presumes that the
current working directory of the process running MEDM is
<code>xxx/xxxApp/op/adl</code>, and it invokes the shell script
<code>../../../start_putrecorder</code> to run the python program
<code>caputRecorder/caputRecorderApp/op/python/caputRecorder.py</code>. The
example version of <i>start_putrecorder</i> tries to ensure that only one copy of
<i>caputRecorder.py</i> is running.
</blockquote>

<li><P><b>Inputs</b>

<ul>


<li><P>The text-monitor field labelled "caput:" displays the PV name and value
most recently written to the IOC.  This field is written to by the
access-security trap listener, and is updated whether or not a python
function is being recorded.

<li><P>The text-entry field labelled "comment:" allows you to add comments to
the python function being recorded.  This field is monitored only while a python
function is being recorded.

<li><P>The text-entry field labelled "delay" specifies the time delay in seconds
of the delay command that will be added to the macro being recorded when you
press the "Add" button.  The actual python code for this command will be
something like <code>time.sleep(1.200)</code>.  After caputRecorder.py has
written the delay command, it will press the "Done" button.

<li><P>The text-entry field labelled "time to wait for completion:" specifies
the time in seconds that python will wait for completion of a macro command 
that does a caput to an EPICS PV, before going on to the next command. 
"Completion" means completion of any EPICS processing that results from the
execution of that caput.  It's ok to change this time while a macro is being
recorded.

</ul>

<li><P><b>Record</b> <ul> <li><P>The text-entry field labelled "function name"
should contain the name of the python function you want to record.  Note that
you aren't permitted to use a function name that already exists in the
<i>macros.py</i> file. Also note that the function name must start with a
letter, and consist of letters digits, and underscores.  caputRecorder will
enforce this by prepending "a" or replacing offending characters with
underscores.

<li><P>The choice button labelled "record puts" is used to start and stop
recording.

</ul>

<li><P><b>Select</b>

<ul>

<li><P>The button labelled "edit macros.py" invokes the command named by
the environment variable EDITOR on the file <i>macros.py</i>.

<li><P>Normally, you should not have to press the "Reload Macros" button,
because <i>caputRecorder.py</i> reloads automatically after a new function has
been recorded. However, if you edit <i>macros.py</i> manually, you must press
"Reload Macros" to tell <i>caputRecorder.py</i> to reread the file. (If you
deleted a function from <i>macros.py</i>, reloading isn't sufficient; you must
restart <i>caputRecorder.py</i>, using the "(re)start recorder" button.)

<li><P>The "Refresh Menus" button is needed whenever <i>macros.py</i> has changed, whether
by recording a function, or by manually editing the file.

<li><P>The text-monitor and text entry fields under the "arguments for selected
function" label are the names and default values of the arguments, if any, of
the selected function.  As recorded, functions have no arguments, but you can
edit the python code.  If you do, you should use the "name=value" syntax for
defining function arguments; otherwise your run-time user will not know which
argument is which.

<li><P>The menu fields labelled "menus of function names:" are the means by which a
function is selected for playback.  Currently the caputRecorder.db database
supports only two menu fields, each of which can hold 16 function names, but
there could be many more.

</ul>

<li><P><b>Playback</b>

<ul>

<li><P>The text-monitor field contains the name of the selected function.  To play
it back (to cause python to execute it) press the "Do" button.  When the
function has finished, the "Do" button will return to the "Done" state.  If you
want to execute the function repeatedly, enter the number of times in the field
labelled "times"

<li><P>The "Abort" button is intended to stop an executing function, and also to do
any other abort-related work specified in the function named "_abort" in
<i>macros.py</i>.  The supplied <i>example_macros.py</i> defines an abort function that aborts
scans, halts motors, and stop the scaler named "scaler1".

</ul>

</ul>

<H2> Selecting what gets recorded </h2>

You probably don't want to record all caputs that happen among your IOCs and
clients, but only those done by users.  One way of filtering was shown above, in
"Requirements, configuration". User-specified filtering is easier, and can be
done at run time with caputRecorder's user interface. <ol>

<li>You can choose which users' caputs will be recorded by specifying usernames
to <code>caputRecorderUsers</code>.  (See "Record caputs from whom?" in
the figure below.)  To disable recording from a specific user, put a minus sign
in front of the username.

<P><li>You can choose which hosts' caputs will be recorded by specifying
hostnames to <code>caputRecorderHosts</code>.  (See "Record caputs from whom?"
in the figure below.)  Only the first element of a host name need be specified.  (For
example, "mooneylinux.aps.anl.gov" is used as "mooneylinux".)

<P><li>You can choose which IOCs caputRecorder monitors, by specifying prefixes
to <code>caputRecorderPrefixes</code>.  (See "Record caputs received by which IOCs?" in
the figure below.)  Unlike user and host choices, this choice does not take
effect while a macro is being recorded.  Also unlike user and host choices, this
choice is not about the sender of a caput, but about the recipient.

<P>On startup, caputRecorder monitors the iocs whose prefixes are specified on the
command line.  If <code>caputRecorderPrefixes</code> is not empty, it will
override the initial list of iocs.

<P><li>Caputs within an IOC will never be recorded, because they don't go
through access security.

<P><center><IMG SRC="caputRecorderConfigure.adl.jpg"><br>caputRecorderConfigure.adl</IMG></center>

<H2> Discussion </h2>

<ul>

<li><P>

<P>caputRecorder "reads" the <i>macros.py</i> file by importing it:

<pre>
import macros.py
</pre>

After <i>macros.py</i> has been changed, caputRecorder "rereads" it by
reloading :

<pre>
reload(macros)
</pre>

Reload will overwrite objects in the live <i>macros</i> module with  values from
the <i>macros.py</i> file, but it will not delete any objects.  If you delete a
function or global variable from <i>macros.py</i>, reloading won't get rid of
it; you have to restart python, which you can do by pressing the "(re)start
recorder" button.

<li><P>
caputRecorder records a caput with the following python code:

<pre>
epics.caput("xxx:scan1.P1PV","xxx:m2.VAL", wait=True, timeout=300.0)
</pre>

This code will request a completion callback from EPICS, and will wait as long
as 300 seconds for the callback to arrive.  This is probably much longer than
most operations will take to complete, but five minutes is not long enough for
many scans.  If you use caputRecorder to execute scans, you'll probably want to
increase the "time to wait for completion" described in the "How to
use"/"Inputs" section.

<P>Currently, it is not an error for a macro to timeout while waiting for a
callback.  Python will simply move on to the next command and execute it.
Currently, caputRecorder does not take advantage of PyEpics' ability to execute
several commands and then wait for all to complete (that is, the "use_complete"
option of the PV class's put() method).

<li><P><a href="http://www-csr.bessy.de/control/SoftDist/caPutLog">caPutLog</a>
can also trap caputs and write them to a PV.  A proof-of-principle
implementation of caputRecorder used caPutLog 3.4 to do this, but it didn't
handle long strings.

<li><P>In EPICS 3.14.12.4 and earlier, and in versions of 3.15 earlier than
3.15.2, access security did not provide the data from a caput to the
asTrapListener, so caputRecorder used dbGetField() to get the data after it had
been written. This was ok for most PVs, but some PVs (for example, the tweak
fields of a motor record) have their values changed immediately after being
written, and caputRecorder was getting the final value, rather than the value
the user actually wrote.  Andrew Johnson fixed this by providing data to the
asTrapListener, and caputRecorder R1-4 and later will use this capability if it
is present.

 </BODY>
