<HTML> <HEAD>
<TITLE>caputRecorder</TITLE>
</HEAD>
<BODY>

<H1> caputRecorder </h1>

caputRecorder supports the recording and playback of a series of caputs (e.g.,
mouse clicks and typing into an MEDM window).  It records each caput as a python
command, and a series of caputs as a python function - also called here a
<b><i>macro</i></b>.  caputRecorder can also serve as a simple user interface
for delivering canned python functions to end users.

<H2> How does this work? </h2>

EPICS access security has the ability to call a user function whenever a caput
that meets certain requirements is received by an IOC.  The function is called
an <i>access-security trap listener</i>, and caputRecorder provides one which
writes a <i>caput-notification</i> string of the form "pvname,value,user@host"
to an EPICS PV whenever an eligible caput is received by the IOC.

<p>caputRecorder provides an EPICS database that contains the EPICS PV mentioned
above, and other PVs that function as caputRecorder's user interface.  The user-
interface PVs are monitored by the python program caputRecorder.py, and direct
its operation.  When caputRecorder.py is given a function name and told to
record, it begins monitoring the caput-notification PVs of specified IOCs, and
writes python commands corresponding to each notification into the python
program file macros.py.

<P>caputRecorder.py also inspects the file macros.py and writes the names of
functions in the file to a set of EPICS menus (that is, to mbbo records).  A
user can select a function name from those menus, and tell caputRecorder to
execute that function.

<P>Thus, each IOC is responsible for telling caputRecorder that it received a
caput, and one IOC also tells caPutRecorder what to do.

<H2> Requirements, configuration </h2>

The workstation on which <i>caputRecorder.py</i> runs must have python with
the <a href="http://cars.uchicago.edu/software/python/pyepics3">PyEpics</a>
module installed.

<P>EPICS IOCs that participate in caputRecorder, either by posting the caputs
they receive, or by hosting caputRecorder's user interface, must be prepared as
follows.  (These are excerpts from the synApps xxx module, release R5-8, which
is already configured to use caputRecorder.)

<ol>
<li><P>Add <code>CAPUTRECORDER</code> to the IOC's RELEASE file

<li><P>Include <code>caputRecorder.dbd</code> in the IOC's .dbd file.

<li><P>Link the IOC's code against the <code>caputRecorder</code> library.

<li><P>Load the database <code>caputRecorder.db</code>, for example with this
excerpt from st.cmd:

<blockquote>
<pre>
dbLoadRecords("$(CAPUTRECORDER)/caputRecorderApp/Db/caputRecorder.db","P=xxx:,N=300")
</pre>
</blockquote>

<blockquote>
where <code>N</code> is the length of the longest caput-notification string
("pvname,value,user@host") that will be sent to the recorder.
</blockquote>

<li><P>If you're using autosave, you'll probably also want to include
<code>caputRecorder_settings.req</code> in the IOC's
<code>auto_settings.req</code> file:

<pre>
file caputRecorder_settings.req P=xxx:,N=300
</pre>

If you do this, you must also add the following line to save_restore.cmd:

<pre>
set_requestfile_path("$(CAPUTRECORDER)", "caputRecorderApp/Db")
</pre>


<li>Register caputRecorder's access-security trap listener, for example with the
following excerpt from st.cmd.  (Note that this command must be executed
<i>after</i> iocInit.)

<blockquote>
<pre>
registerCaputRecorderTrapListener('xxx:caputRecorderCommand')
</pre>
</blockquote>

<blockquote>

where <code>xxx:caputRecorderCommand</code> is the name of the PV to which
caput-notification strings will be written.

</blockquote>

<li>Run EPICS access security with an access-security file that specifies
<code>TRAPWRITE</code> for the desired users and hosts.  Here is a sample
excerpt from st.cmd:

<blockquote>
<pre>
asSetFilename("$(TOP)/iocBoot/accessSecurity.acf")
</pre>
</blockquote>

where the file <code>accessSecurity.acf</code> might have the following content:

<blockquote>
<pre>
HAG(workstation) {mooneylinux.aps.anl.gov}
UAG(user) {mooney}
ASG(DEFAULT) {
	RULE(1,READ)
	RULE(1,WRITE,TRAPWRITE) {
		HAG(workstation)
		UAG(user)
	}
	RULE(1,WRITE)
}
</pre>

<P>This file grants write permission to anybody on any host, and specifies that
TRAPWRITE is in effect only for user <i>mooney</i> on workstation
<i>mooneylinux</i>.  You probably don't want TRAPWRITE in effect for caputs from
an IOC, but do want it for caputs from channel-access clients, such as MEDM, that
aren't in an IOC.

<P>Note that the order in which rules occur in the file matters for TRAPWRITE. 
If <code>RULE(1,WRITE)</code> were encountered before
<code>RULE(1,WRITE,TRAPWRITE)</code>, TRAPWRITE would not be in effect for
anybody, because everybody is covered by <code>RULE(1,WRITE)</code>.

<P>If you can't or don't want to select users and hosts using access-security
rules, you can specify TRAPWRITE for all, and select users and hosts with
caputRecorder's user interface.  The simplest possible access-security file that
will work for caputRecorder is the following:

<pre>
ASG(DEFAULT) {
	RULE(1,WRITE,TRAPWRITE)
}
</pre>
</blockquote>


<li>One IOC from which caputs are to be recorded will have its
<code>caputRecorder.db</code> database displayed to the user via MEDM (or
caQtDM, or CSS-BOY).  The Python program <i>caputRecorder.py</i> will also
monitor and write to this database.

<P><center><IMG SRC="caputRecorder.adl.jpg"><br>caputRecorder.adl</IMG></center>

<P><li>The workstation on which this display is running must have the file
<code>start_putrecorder</code> in its top-level directory (which I'll call
<code>xxx</code>), and the file <i>macros.py</i> in
<code>xxx/xxxApp/op/python</code>.  An example copy of
<code>start_putrecorder</code> (from the synApps xxx module) is available as
<code>caputRecorder/example_start_putrecorder</code>.

An example copy of <i>macros.py</i> is
available as <code>caputRecorder/caputRecorderApp/op/python/example_macros.py</code>.

<P><li>Set the environment variable EDITOR to your preferred text editor, so
that the button labelled "!edit macros.py" above will work.
</ol>

<h2>How to use</h2>

Referring to the caputRecorder.adl display above, from top to bottom:

<ul>

<li><P>The button labelled "(re)start recorder" starts or restarts the python
program <i>caputRecorder.py</i>

<blockquote>
As implemented, the MEDM display presumes that the
current working directory of the process running MEDM is
<code>xxx/xxxApp/op/adl</code>, and it invokes the shell script
<code>../../../start_putrecorder</code> to run the python program
<code>caputRecorder/caputRecorderApp/op/python/caputRecorder.py</code>. The
example version of <i>start_putrecorder</i> tries to ensure that only one copy of
<i>caputRecorder.py</i> is running.
</blockquote>

<li><P><b>Inputs</b>

<ul>


<li><P>The text-monitor field labelled "caput:" displays the PV name and value
most recently written to the IOC.  This field is written to by the
access-security trap listener, and is updated whether or not a python
function is being recorded.

<li><P>The text-entry field labelled "comment:" allows you to add comments to
the python function being recorded.  This field is monitored only while a python
function is being recorded.

</ul>

<li><P><b>Record</b>
<ul>
<li><P>The text-entry field labelled "function name" should contain the
name of the python function you want to record.  Note that you aren't permitted
to use a function name that already exists in the <i>macros.py</i> file.

<li><P>The choice button labelled "record puts" is used to start and stop
recording.

</ul>

<li><P><b>Select</b>

<ul>

<li><P>The button labelled "edit macros.py" invokes the command named by
the environment variable EDITOR on the file <i>macros.py</i>.

<li><P>Normally, you should not have to press the "Reload Macros" button,
because <i>caputRecorder.py</i> reloads automatically after a new function has
been recorded. However, if you edit <i>macros.py</i> manually, you must press
"Reload Macros" to tell <i>caputRecorder.py</i> to reread the file. (If you
deleted a function from <i>macros.py</i>, reloading isn't sufficient; you must
restart <i>caputRecorder.py</i>, using the "(re)start recorder" button.)

<li><P>The "Refresh Menus" button is needed whenever <i>macros.py</i> has changed, whether
by recording a function, or by manually editing the file.

<li><P>The text-monitor and text entry fields under the "arguments for selected
function" label are the names and default values of the arguments, if any, of
the selected function.  As recorded, functions have no arguments, but you can
edit the python code.  If you do, you should use the "name=value" syntax for
defining function arguments; otherwise your run-time user will not know which
argument is which.

<li><P>The menu fields labelled "menus of function names:" are the means by which a
function is selected for playback.  Currently the caputRecorder.db database
supports only two menu fields, each of which can hold 16 function names, but
there could be many more.

</ul>

<li><P><b>Playback</b>

<ul>

<li><P>The text-monitor field contains the name of the selected function.  To play
it back (to cause python to execute it) press the "Do" button.  When the
function has finished, the "Do" button will return to the "Done" state.  If you
want to execute the function repeatedly, enter the number of times in the field
labelled "times"

<li><P>The "Abort" button is intended to stop an executing function, and also to do
any other abort-related work specified in the function named "_abort" in
<i>macros.py</i>.  The supplied <i>example_macros.py</i> defines an abort function that aborts
scans, halts motors, and stop the scaler named "scaler1".

</ul>

</ul>

<H2> Selecting what gets recorded </h2>

You probably don't want to record all caputs that happen among your IOCs and
clients, but only those done by users.  One way of filtering was shown above, in
"Requirements, configuration". User-specified filtering is easier, and can be
done at run time with caputRecorder's user interface. <ol>

<li>You can choose which users' caputs will be recorded by specifying usernames
to <code>caputRecorderUsers</code>.  (See "Record caputs from whom?" in
the figure below.)  To disable recording from a specific user, put a minus sign
in front of the username.

<P><li>You can choose which hosts' caputs will be recorded by specifying
hostnames to <code>caputRecorderHosts</code>.  (See "Record caputs from whom?"
in the figure below.)  Only the first element of a host name need be specified.  (For
example, "mooneylinux.aps.anl.gov" is used as "mooneylinux".)

<P><li>You can choose which IOCs caputRecorder monitors, by specifying prefixes
to <code>caputRecorderPrefixes</code>.  (See "Record caputs from which IOCs?" in
the figure below.)  Unlike user and host choices, this choice does not take
effect while a macro is being recorded.

<P><li>Caputs within an IOC will never be recorded, because they don't go
through access security.

<P><center><IMG SRC="caputRecorderConfigure.adl.jpg"><br>caputRecorderConfigure.adl</IMG></center>

<H2> Discussion </h2>

<ul>

<li><P>

<P>caputRecorder "reads" the <i>macros.py</i> file by importing it:

<pre>
import macros.py
</pre>

After <i>macros.py</i> has been changed, caputRecorder "rereads" it by
reloading :

<pre>
reload(macros)
</pre>

Reload will overwrite objects in the live <i>macros</i> module with  values from
the <i>macros.py</i> file, but it will not delete any objects.  If you delete a
function or global variable from <i>macros.py</i>, reloading won't get rid of
it; you have to restart python, which you can do by pressing the "(re)start
recorder" button.

<li><P>
caputRecorder records a caput with the following python code:

<pre>
epics.caput("xxx:scan1.P1PV","xxx:m2.VAL", wait=True, timeout=300)
</pre>

This code will request a completion callback from EPICS, and will wait as long
as 300 seconds for the callback to arrive.  This is probably much longer than
most operations will take to complete, but five minutes is not long
enough for many scans.  If you use caputRecorder to execute scans, plan to edit
the macros.py file to increase the timeout for writes to xxx:scan1.EXSC.

<P>Currently, it is not an error for a macro to timeout while waiting for a
callback.  Python will simply move on to the next command and execute it.
Currently, caputRecorder does not take advantage of PyEpics' ability to execute
several commands and then wait for all to complete (that is, the "use_complete"
option of the PV class's put() method).

<li><P><a href="http://www-csr.bessy.de/control/SoftDist/caPutLog">caPutLog</a>
can also trap caputs and write them to a PV.  A proof-of-principle
implementation of caputRecorder used caPutLog 3.4 to do this, but it didn't
handle long strings.

 </BODY>
